참여인원 4  
> 잡부 : https://github.com/lordchiwoo/algo_programmers  
> 산당 : https://github.com/JhonverKing/AlgoStudy  
> 가니 : https://github.com/kwan1989/algorithm_Programmers  
---
## 입국심사 (2021. 07. 12) Entry Audit (Binary Search)
### 문제 및 풀이 주소
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/43238)  
[Git Solution](https://github.com/mertyn88/algorithm/blob/master/src/com/algorithm/programmers/entryaudit/Solution.java)

### 문제 설명
> n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.
처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.
**모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.**
입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

> 제한사항
* 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
* 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
* 심사관은 1명 이상 100,000명 이하입니다.

<details>
<summary>내용 보기</summary>
<div markdown="6">

|n|times|return|
|---|---|---|
|6|[7, 10]|28|

### 입출력 설명
* 가장 첫 두 사람은 바로 심사를 받으러 갑니다.
* 7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.
* 10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.
* 14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.
* 20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.

### 문제 해결

#### 이슈 케이스
`해당 문제에서 이분탐색을 사용해야하는 부분이 어디인가?`에 대한곳을 찾을 수 없었다. 단순히 처음에는 Set으로 각각의 시간을 addAll하여 중복을 제거하고 마지막 n값을 get할 수 있으면 끝일줄 알았다. 하지만 역시나 테스트케이스 실패의 향연... 다시 처음으로 돌아와 이분진법을 사용해야 하는 부분을 찾기 시작했다.

> 문제의 주제가 이분탐색이므로, 어느 부분에는 반드시 이분탐색을 적용해야한다. 이분탐색에서 가장 중요한 요소는 _**정렬**_이 필수로 되어 있어야 한다. 주어지는 배열 times는 정렬이 되어 있지 않으므로 제외해야하고, 그렇다면 남은것은 시간의 _**범위**_이다. ( 실제로는 엄청난 삽질을 하였다 )

심사자가 받을 수 있는 가장 빠른 범위의 시간과, 가장 느린 범위의 시간을 구하는것으로 먼저 고민하였다. 심사관마다 시간이 주어지지만, 문제에서 중복이 안된다고 하지 않았으니까 최소의 시간은 times의 최소값, 최대의 시간은 times의 최대값으로 지정하면 될것 같고, times에서 모든 n값이 최소값과 최대값으로만 이루어진 시간을 구하기로 하였다.

```java
long divide = (long) Math.ceil((double) n / times.length);
//정렬
Arrays.sort(times);
// 최소값
long min = times[0] * divide;
// 최대값
long max = times[times.length - 1] * divide ;
```
스트림 람다를 사용하면, min과 max에 각각 적용해야 하므로, times를 Sort하는 방향으로 생각하였다. 

--- 
이후의 모든 시도는 많은 시간을 들였음에도 전부다 실패하였다... 특히나, 이분탐색을 하는 코드를 긁어와서 재귀의 방식과 while로 하는 방식 둘다 적용을 하였는데 실패했다.

#### 해결 케이스
어떻게 해결해야 할까? 하다가 결국 풀이하는 방식을 보기로 했는데, 특정 공식을 알수 없으면 문제를 해결할 수 없는것 같다.. 탐색하면서 매번 일일이 처음부터 n값이 될때까지 모든걸 계산해야 하나? 했더니 다음과 같은 공식이 있었다.
```java
for(int time : times){
    sum += int(((low+high) / 2) / time)
}
```
모든 사람을 계산하지 않고 해당 공식하나만으로 심사받는 사람의 수를 구할 수 있다... ( 너무 허무했다..) 
하지만 바로 성공할 수는 없었는데 이분탐색 예제를 그대로 적용하였더니 원하는 수가 나오지 않고 전체 탐색을 하면 다른값이 나오기 시작했다.

```java
if(sum == key){
    return mid
}else if(sum > key) {
    high = mid - 1;
} else {
    low = mid + 1;
}
```
key값이 심사받은 사람수 인데 구글링해온 이분탐색 코드는 원하는 값을 찾았을 경우, 바로 return 하는 코드였다. 해당 코드를 그대로 적용하였는데, 당연하게도 실패하였다. 실패원인은 다음과 같다.
> 특정값에서 `sum == key`의 조건이 이루어지지만, 그다음값도, 그다다음값도 `sum == key`의 값이 되는 조건들이 있다. 

여러 sum ==key의 조건 때문에 처음에는 times각각의 값에서 배수값이 필요하지 않을까 생각했는데, 실제 코드를 보니 그럴필요가 없다는것을 알았다. ( 애초에 저렇게 나누어서 저장하면 최소값이 배열값으로 되는것 같다. )

```java
if(sum < key) {
    low = mid + 1;
} else {
high = mid - 1;
    result = mid;
}
```
sum == key의 조건이 사라지고 부등호의 방향이 바뀌어서 처리되었다.
부등호의 방향은 상관없을 줄알았는데 해당 표시가 바뀜에 따라 값이 달라지게 되었다. 


### 테스트 결과

|테스트 번호|통과여부|메모리 및 시간|테스트 번호|통과여부|메모리 및 시간|
|---|---|---|---|---|---|
|테스트 1|통과|(0.72ms, 52MB)|테스트 6|통과|(109.47ms, 60MB)
|테스트 2|통과|(0.60ms, 53MB)|테스트 7|통과|(100.97ms, 60.5MB)
|테스트 3|통과|(2.64ms, 55.4MB)|테스트 8|통과|(138.49ms, 60.7MB)
|테스트 4|통과|(105.26ms, 59.6MB)|테스트 9|통과|(0.74ms, 52.4MB)
|테스트 5|통과|(100.82ms, 58.1MB)


### 후기
해당 문제는 좀... 사람수를 구하는 공식을 모르면 절대로 풀수 없는 문제 같았다. 시간도 많이 걸렸거니와 저 문제의 공식을 혼자서 스스로 도출한 것이 아니기 때문에 찝찝함이 많은 문제였다. 실제 정답코드는 저리 짧은데..

</div>
</details>

---

## 순위 (2021. 07. 04) Graph (BFS)
### 문제 및 풀이 주소
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/49191?language=java)  
[Git Solution](https://github.com/mertyn88/algorithm/blob/master/src/com/algorithm/programmers/setrank/Solution.java)

### 문제 설명
> n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, `만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다`. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.
선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.

> 제한사항
* 선수의 수는 1명 이상 100명 이하입니다.
* 경기 결과는 1개 이상 4,500개 이하입니다.
* results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.
* 모든 경기 결과에는 모순이 없습니다.

<details>
<summary>내용 보기</summary>
<div markdown="5">

|n|vertex|return|
|---|---|---|
|5|[[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]]|2|

### 입출력 설명
* 2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.
* 5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.

### 문제 해결

#### 이슈 케이스
초반 문제 해결 설계시, 승자에 대한 리스트와 패배에 대한 리스트를 따로 저장을 해야할 것 같았다. 각각의 리스트를 만든 후 필터링을 하면 원하는 답을 구할 수 있을 것같았다. 초반 생각한 설계는 다음과 같다.
* 노드별 승리 데이터 셋이 없으면 마지막 순위 확정이다.
* 노드별 패배 데이터 셋이 없으면 1순위 확정이다.
* 1순위 또는 마지막 순위를 알 수가 없는 상황이면 어떠한 노드도 정확한 순위를 구할 수 없다고 판단되어서 0값을 반환한다.

단, 조건에 해당하는 **노드의 개수가 2개 이상이면 해당 노드들은 전부 순위를 알수 없으므로 제외**한다.

> 예제에서 주어진 데이터 셋에서 5번 노드가 승리셋이 없으므로 5위가 확정이며, 승리 데이터 셋에서 패배가 없는 1, 4번 노드들은 개수가 2개이므로 제외한다.
즉, `1, 4 노드는 제외 대상, 5번 노드는 확정 대상`이다.

이후 남은 노드인 2, 3노드에 대해서 확정 노드에서 탐색알고리즘을 통해서 원하는 결과를 찾으면 되리라 생각되었다.
하지만 여기서 문제점이 발견되었는데, 확정 5번 노드에 의해서 2번 노드의 순위가 4위인것을 알게 되었지만, 2번 노드와 3번 노드에 대해 단순히 연결값으로는 순위에 대한 부분을 알 수가 없게 되었다. 추가적인 조건이 필요한데 방식이 점점더 산으로 가게 되었다.

#### 해결 케이스
승리, 패배 데이터셋을 만드는 부분은 큰 문제가 없다고 판단되었는데, 문제에서 다음과 같은 지시문을 처리하지 않았음을 깨달았다.
> 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다
* A > B가 성립하고, B > C가 성립한다면, A > C는 성립합니다.

해당 말이 무슨말인고 하니, 초기 만들었던 데이터 셋에서 주어진 vertex를 가지고만 데이터셋을 만드는것이 아닌, 위의 조건에 해당하는 노드들을 추가로 만들면 될까? 하는 생각이 들었다. 종이에 끄적이면서 실제 주어지는 데이터는 아니지만, A > C의 조건이 되는 노드들은 탐색을 통해서 내용이 포함되어있으면 성립함을 알게 되었다.
> _**[1, 2]**_, _**[2, 5]**_에 대해서
 * 1은 2에 승리한다.
 * 2는 5에 승리한다.
 * 즉, 1은 2와 5에 승리한다.
 
가상의 결과셋을 승리와 패배로 나뉘어 수행하고 비교를 해보았더니, 승리셋과 패배셋을 병합하였더니 순위 대상이 되는 노드는 모든 노드들이 포함되어 있었다. (Set으로 하였기 때문에 중복은 제거 된다.)

#### 코드 - 1차 승패 데이터
```java
/*
[1차] 노드별 승리 데이터 셋
1 = [2]
2 = [5]
3 = [2]
4 = [2, 3]
5 = []

[1차] 노드별 패배 데이터 셋
1 = []
2 = [1, 3, 4]
3 = [4]
4 = []
5 = [2]
*/

// 맵 초기화 (주어진 데이터셋을 모두 가지기 위함)
IntStream.rangeClosed(1, nodeCount).forEach(node -> {
    winnerMap.put(node, new HashSet<>());
    loserMap.put(node, new HashSet<>());
});

// [1차] 승리, 패배 데이터 셋 구축
for(int[] arr : results){
    //승리 arr[0] 패매 arr[1]
    winnerMap.merge(arr[0], new HashSet<>(){{add(arr[1]);}}, (e, i) -> new HashSet<>(){{addAll(e);addAll(i);}});
    loserMap.merge(arr[1], new HashSet<>(){{add(arr[0]);}}, (e, i) -> new HashSet<>(){{addAll(e);addAll(i);}});
}
```

#### 코드 - 2차 승패 데이터 (가상의 승패 노드 추가)
```java
/*
[2차] 노드별 승리 데이터셋을 기준으로 가상 승리 노드셋 계산 ( 자기 자신은 항상 포함, 괄호는 가상으로 만들어진 노드셋 )
1 = [1, 2, (5)]
2 = [2, 5]
3 = [2, 3, (5)]
4 = [2, 3, 4, (5)]
5 = [5]

[2차] 노드별 패배 데이터셋을 기준으로 가상 패배 노드셋 계산 ( 자기 자신은 항상 포함, 괄호는 가상으로 만들어진 노드셋 )
1 = [1]
2 = [1, 2, 3, 4]
3 = [3, 4]
4 = [4]
5 = [(1), 2, (3), (4), 5]
*/

// [2차] 승리, 패배 가상 데이터 셋 구축 ( 각자 for 문에서 리팩토링 )
for(Map scoreMap : new Map[]{winnerMap, loserMap}){
    for(Object  key : scoreMap.keySet()){
        bfs((Integer)key, scoreMap);
    }
}
```
```java
// BFS 메소드
public void bfs(Integer node, Map<Integer, Set<Integer>> scoreMap){
    Set<Integer> tempSet = new HashSet<>();                     // BFS 내에서 사용되는 임시 셋
    boolean[] isVisit = new boolean[nodeCount];                 // 방문 배열 초기화 (예전 속도 이슈로 방문리스트 -> 방문 배열로 변경)
    Queue<Integer> queue = new LinkedList<>(){{add(node);}};    // BFS 큐

    //Queue loop
    while(!queue.isEmpty()){
        int queueNode = queue.poll();
        // 노드 추가
        tempSet.add(queueNode);
        for(int iNode : scoreMap.get(queueNode)){
            // 방문 체크
            if(!isVisit[iNode - 1]){
                isVisit[iNode - 1] = true; //방문 추가
                queue.add(iNode);
            }
        }
    }
    scoreMap.put(node, tempSet);            // 승리 또는 패배 데이터 셋 신규 데이터 추가
}
```

#### 코드 - 승패 데이터 ( 데이터 병합 )
```java
/*
[3차] 승리 데이터 셋과 패배 데이터 셋을 합쳤을 경우 노드셋 계산
1 = [1, 2, (5)]
2 = [1, 2, 3, 4, 5]
3 = [2, 3, 4, (5)]
4 = [2, 3, 4, (5)]
5 = [(1), 2, (3), (4), 5]
*/

// [3차] 승리데이터 와 패배 데이터를 머지
IntStream.rangeClosed(1, nodeCount).forEach(node ->
mergeMap.put(node, new HashSet<>(){{addAll(winnerMap.get(node));addAll(loserMap.get(node));}}));
```

#### 코드 - 결과 데이터 반환
```java
// 승리데이터셋과 패배데이터셋을 합쳤을때, 모든 노드들이 표현되는 노드 개수 반환
return (int)mergeMap.values().stream().filter(value -> value.size() == n).count();
```


### 테스트 결과

|테스트 번호|통과여부|메모리 및 시간|테스트 번호|통과여부|메모리 및 시간|
|---|---|---|---|---|---|
|테스트 1|통과|(10.46ms, 54MB)|테스트 6|통과|(12.47ms, 54.7MB)
|테스트 2|통과|(12.18ms, 52.5MB)|테스트 7|통과|(48.39ms, 57.2MB)
|테스트 3|통과|(9.40ms, 52.9MB)|테스트 8|통과|(64.00ms, 64.3MB)
|테스트 4|통과|(10.26ms, 53.4MB)|테스트 9|통과|(100.88ms, 69.8MB)
|테스트 5|통과|(11.91ms, 53.4MB)|테스트 10|통과|(144.90ms, 83.6MB)

### 후기
나름 이번에는 바로 무작정 개발하지 않고, 설계를 오랫동안 하였는데, 결국 1차는 무난히 실패해버렸다. 혼자서 하는 생각의 설계는 여러가지 예외케이스를 찾아내지 못하였고, 오랜 개발시간을 들였는데 다시 롤백하게되었다. ( 이번에는 부분 롤백이였지, 전체 롤백이면... )
시간의 제한을 두지 않고 오랜시간 생각하고 테스트 하였기에 해결했지, 실제 시간제한 있는 코딩테스트를 보게되면
한문제나 맞출까 싶다... 아직 멀었다.

</div>
</details>

---

## 가장 먼 노드 (2021. 06. 28) Graph (BFS)
### 문제 및 풀이 주소
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/49189)  
[Git Solution](https://github.com/mertyn88/algorithm/blob/master/src/com/algorithm/programmers/longnode/Solution.java)

### 설명
> n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다.
> 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.
> 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.

> 제한사항
> * 노드의 개수 n은 2 이상 20,000 이하입니다.
> * 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.
> * vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.

<details>
<summary>내용 보기</summary>
<div markdown="4">

![](https://images.velog.io/images/mertyn88/post/78916a7e-c778-4cca-bf8b-5e71cc09aea2/image.png)

|n|vertex|return|
|---|---|---|
|6|[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]|3|

### 문제 해결

#### 이슈 케이스
해당 문제를 해결하기 위해서 처음에는 DFS를 사용했었다. 하지만 DFS를 사용함과 동시에 처리해야할 for loop가 점점 많아지고, 원하는 결과는 나오지 않고, 간신히 예제를 통과했더니 모든 테스트 케이스에서 런타임 에러 및 예외가 발생하였다.

1차적인 문제의 원인은 다음과 같았다.
* 해당 문제는 BFS가 효과적이다. DFS의 경우 모든 이동 경로를 탐색하므로 뎁스의 구별이 없다.
* 가장 먼 노드는 가장 뎁스의 깊이 가 긴 노드들 이다.

처음에 주어진 사진의 예제 그림으로는 DFS로 5번노드와 6번 노드를 구할수 있었는데 4번의 경우 양방향으로 이어진 2번과 3번 노드들이 있기에 많은 고민과 삽질을 하였다. ( 코딩시간에만 6시간 이상 할애 한듯 ) 하지만 스터디 인원과의 대화를 통해서 예제 그래프를 살짝만 돌려보면, 4번, 5번, 6번 노드가 3뎁스의 위치에 존재하여 3개의 노드가 가장먼 노드가 된다는 사실을 깨달았다.

#### BFS를 위한 인접 리스트 Set 만들기
> 해당 문제는 단순 BFS가 아니고 Graph 이므로 인접노드셋이 필요하다. (보통 알고리즘 BFS 예제에서 보던 처음에 주어지는 노드셋이다. ) 해당 노드셋을 만들기 위해 다음과 같은 setData() 메소드를 추가한다.
```java
// 만들어진 인접노드 리스트
{1=[2, 3], 2=[1, 3, 4, 5], 3=[1, 2, 4, 6], 4=[2, 3], 5=[2], 6=[3]}
```

```java
//인접노드리스트
public void setData(int n, int[][] edge){
    for(int idx = 1; idx <= n; idx++){
        for (int[] arr : edge) {
            if (idx == arr[0]) {
                addEdge(idx, arr[1]);
            } else if (idx == arr[1]) {
                addEdge(idx, arr[0]);
            }
        }
    }
}

//키값이 존재하면 기존의 값에 append, 존재 하지 않으면 새로 put
//Map.merge를 이용하면 속도가 좀더 느려져서 변경하였다.
void addEdge(int key, int adjacent) {
    if(adjacentMap.containsKey(key)){
        adjacentMap.get(key).add(adjacent);
    }else{
        adjacentMap.put(key, new HashSet<>(){{
            add(adjacent);
        }});
    }
}
```


#### BFS 처리 중 Depth 구별
>과거 BFS/DFS의 예제를 정리한것이 있어서 해당 방식을 적용하였는데, 예제에서는 탐색의 순서를 정해줄 뿐, 언제 어떠한 노드가 깊이의 마지막인지를 처리하는 로직은 없다. 해서 코드를 분석 결과, 하나의 Queue가 비어졌을 때 한번의 깊이가 종료된다고 생각하였고, 해당 방식을 처리하기 위해 Switch Queue를 이용하여 처리하였다.

```java
// adjacent list loop
for (int loopKey : adjacentMap.get(queueKey)) {
    if (!visitedList.contains(loopKey)) {
        visitedList.add(loopKey);
        tempQueue.add(loopKey);
    }
}

if(queue.size() == 0){
    //뎁스별 노드 삽입
    if(tempQueue.size() != 0){
        answer = tempQueue.size();  // 마지막 tempQueue 사이즈가 마지막 뎁스의 노드 개수
        queue.addAll(tempQueue);
        tempQueue.clear();
    }
}
```

#### 시간초과 이슈 발생 (Critical)
> 개발 이후 실제 테스트케이스를 돌려보니 테스트케이스 7,8,9번에서 엄청난 속도가 걸렸고, 테스트8번같은 경우는 시간초과가 발생하였다.

|테스트 번호|통과여부|메모리 및 시간|테스트 번호|통과여부|메모리 및 시간|
|---|---|---|---|---|---|
|테스트 1|통과|(0.55ms, 53MB)|테스트 6|통과|(96.47ms, 57.3MB)
|테스트 2|통과|(0.57ms, 52.2MB)|테스트 7|통과|(3816.47ms, 76.7MB)
|테스트 3|통과|(1.00ms, 53.2MB)|테스트 8|실패|(시간 초과)
|테스트 4|통과|(8.14ms, 56.1MB)|테스트 9|통과|(7040.84ms, 81.1MB)
|테스트 5|통과|(51.55ms, 58.2MB)|

시간초과가 발생한 원인을 스터디원과 함께 분석한 결과 다음과 같았다.
##### 인접노드리스트를 만드는 Loop
> 인접노드 리스트를 만들때, n개의 노드를 Loop하며 edge[][]를 다시 Loop하는데 이러면 n * edge 만큼의 Loop가 발생하므로 속도에서의 차이가 발생한다.
해서 다음과 같이 코드를 변경하였다.

```java
// 시간초과 해결한 코드
public void setData(int n, int[][] edge){
    for (int[] arr : edge) {
        addEdge(arr[0], arr[1]);
        addEdge(arr[1], arr[0]);
    }
    visitArray = new boolean[n];
}
```
하지만 해당 구조를 변경해도 테스트 케이스8번을 통과할수 없었다...

##### 방문리스트를 체크하는 데이터 구조
> 실무에서 사용하는 데이터구조를 이용하기로 마음먹었기 때문에 배열을 사용하지 않고 List를 자주 이용하는데 List의 contains로 체크하는 부분도 생각보다 속도에 영향을 준다고 하였다. 실제로 코드내에서 방문리스트는 전체 탐색을 통하는데 반해 ( 발견하면 그때는 멈추기는 하겠지...) 방문 배열은 해당 인덱스를 명시하므로 속도에서 크게 차이가 날것으로 생각된다.
해서 다음과 같이 데이터 구조가 변경되었다.

```java
//방문배열 선언, 초기화는 setData에서 n개 만큼 이루어진다.
private boolean[] visitArray = null;
...
//노드는 1번부터 시작이므로 실제 방문리스트 체크는 노드 - 1 을 한다.
if (!visitArray[loopKey - 1]) {
    visitArray[loopKey - 1] = true;
    tempQueue.add(loopKey);
}
```

### 코드 개선 이후 결과

|테스트 번호|통과여부|메모리 및 시간|테스트 번호|통과여부|메모리 및 시간|
|---|---|---|---|---|---|
|테스트 1|통과|(0.40ms, 52.3MB)|테스트 6|통과|(9.54ms, 58.6MB)
|테스트 2|통과|(0.46ms, 52.9MB)|테스트 7|통과|(101.81ms, 77.4MB)
|테스트 3|통과|(0.73ms, 54.5MB)|테스트 8|통과|(92.72ms, 75.5MB)
|테스트 4|통과|(1.66ms, 53.6MB)|테스트 9|통과|(86.50ms, 77.9MB)
|테스트 5|통과|(6.90ms, 53.7MB)


### 후기
알고리즘을 풀면서 항상 생각한게, `"속도는 조금 걸리더라도 실무에서 많이 사용하는 방식으로 처리하자"` 였다. 
그래서 일부러 배열도 리스트로 변환하여 처리하고 그랬는데, 이번처럼 애초에 테스트 케이스 자체를 통과 할 수 없는 문제에 와버리니 데이터 구조를 배열로 가는 방법도 다시 한번 생각해 봐야할듯 하다.
이번 문제를 해결하면서 굉장히 많은 삽질과 ( 매번하지만,, ) 시간이 소요되었다. 
이럴때마다 정말 현타가 온다 아오...

</div>
</details>

---
## 단어변환 (2021. 06. 20) BFS/DFS
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/43163)  
[Git Solution](https://github.com/mertyn88/algorithm/blob/master/src/com/algorithm/programmers/convertword/Solution.java)  

>두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.
> 1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.
> 2. words에 있는 단어로만 변환할 수 있습니다.

<details>
<summary>내용 보기</summary>
<div markdown="3">

|begin|target|words|return|
|-----|------|-----|:------:|
|"hit"|"cog"|["hot", "dot", "dog", "lot", "log", "cog"]|4|
|"hit"|"cog"|["hot", "dot", "dog", "lot", "log"]|0|
|"hit"|"hhh"|["hhh","hht"]|2|

|테스트 번호|통과여부|메모리 및 시간|
|---------|:-------:|------------|
|테스트 1|통과|(5.77ms, 53MB)
|테스트 2|통과|(7.49ms, 53.2MB)
|테스트 3|통과|(31.36ms, 53.2MB)
|테스트 4|통과|(4.45ms, 54.2MB)
|테스트 5|통과|(3.61ms, 52.3MB)

해당문제를 해결하는데 가장 중요한 포인트는 2가지 였던것 같다.
1. 다음 노드의 집합을 찾을 수 있는가
2. 찾은 노드의 집합군을 어떻게 처리할 것인가
    * target의 정확한 위치값은 필요하지 않다. `해당 집합군에 포함되어 있는가` 이다.
    * 집합군이 없을 경우, 카운트의 횟수와 `집합군을 롤백`해야 한다. 

오랜시간이 걸려서 원하는 결과를 얻었지만, 실제 테스트 3 케이스에서 계속 실패를 하였는데, 찾아보니 다음과 같은 상황이 발생했다.
```bash
hit -> ["hht"] 인경우
```
람다로 두 리스트를 contains하여 개수를 반환하였는데 위의 경우는 값이 2가 나와야 하는데 실제로는 3의 값이 나온다. 그 이유는
* [h]ht 인경우 hit.contains true
* h[h]t 인경우 hit.contains true
* hh[t] 인경우 hit.contains true

코드를 변경하였고 이후 실제 테스트3의 케이스도 통과하였다.

</div>
</details>

---
## 네트워크 (2021. 06. 09) BFS/DFS
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/43162)  
[Git Solution](https://github.com/mertyn88/algorithm/blob/master/src/com/algorithm/programmers/network/Solution.java)  

>컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다.  
>따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.

<details>
<summary>내용 보기</summary>
<div markdown="2">

|n|computers|return|
|---|------|------|
|3|[[1, 1, 0], [1, 1, 0], [0, 0, 1]]|2|
|3|[[1, 1, 0], [1, 1, 1], [0, 1, 1]]|1|

해당 문제에 대해서는...  나의 실력으로 해결한 문제가 아니므로 결과를 기술하지 않는다.  
테스트케이스에 대해서 해결을 하지 못하였고, 시간이 너무 지나서 결국 정답을 살짝 보았지만  
결국 코드가 해답과 비슷해져 버렸다.

</div>
</details>

---
## 타겟넘버 (2021. 06. 07) BFS/DFS
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/43165)  
[Git Solution](https://github.com/mertyn88/algorithm/blob/master/src/com/algorithm/programmers/targetnumber/Solution.java)  

>-1+1+1+1+1 = 3  
>+1-1+1+1+1 = 3  
>+1+1-1+1+1 = 3  
>+1+1+1-1+1 = 3  
>+1+1+1+1-1 = 3

|numbers|target|return|
|-------|------|------|
|[1, 1, 1, 1, 1]|3|5|

|테스트 번호|통과여부|메모리 및 시간|테스트 번호|통과여부|메모리 및 시간|
|---------|:-------:|------------|---------|:-------:|------------|
|테스트 1|통과|(167.02ms, 102MB)|테스트 5|통과|(16.06ms, 53.5MB)|
|테스트 2|통과|(194.38ms, 99.3MB)|테스트 6|통과|(4.00ms, 53MB)|
|테스트 3|통과|(3.40ms, 52.5MB)|테스트 7|통과|(3.28ms, 52.1MB)|
|테스트 4|통과|(7.61ms, 52.5MB)|테스트 8|통과|(7.75ms, 53.6MB)|

연습한 DFS를 사용하고 싶었지만, 또다시 테스트케이스에서 지속적인 예외가 발생하였다.  
또다시 편법을 사용해야 했으며, 모든 케이스에 대해 전체 계산이 이루어진 후, 필요 번호를 stream api로  
추출하는 방식을 취했다. 그러다보니 테스트 케이스에서 엄청난 시간과 메모리양이 소요되었다.

---
## 프린터 (2021. 05. 30)  Stack/Queue
[Programmers](https://programmers.co.kr/learn/courses/30/lessons/42587)  
[Git Solution](https://github.com/mertyn88/algorithm/blob/master/src/com/algorithm/programmers/printer/Solution.java)  

> 1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.
> 2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.
> 3. 그렇지 않으면 J를 인쇄합니다.

<details>
<summary>내용 보기</summary>
<div markdown="1">

|priorities |location|return
|-----------|--------|------|  
|[2, 1, 3, 2]|2|1|
|[1, 1, 9, 1, 1, 1]|0|5|

|테스트 번호|통과여부|메모리 및 시간|테스트 번호|통과여부|메모리 및 시간|
|---------|:-------:|------------|---------|:-------:|------------|
|테스트 1|통과|(37.06ms, 52.7MB)|테스트 11|통과|(45.89ms, 54.1MB)|
|테스트 2|통과|(89.72ms, 54.9MB)|테스트 12|통과|(33.65ms, 52.8MB)|
|테스트 3|통과|(57.63ms, 54.4MB)|테스트 13|통과|(55.14ms, 54.9MB)|
|테스트 4|통과|(31.50ms, 52.9MB)|테스트 14|통과|(11.64ms, 53.5MB)|
|테스트 5|통과|(10.50ms, 54MB)|테스트 15|통과|(27.03ms, 52.7MB)|
|테스트 6|통과|(38.47ms, 52.8MB)|테스트 16|통과|(19.79ms, 53.7MB)|
|테스트 7|통과|(42.19ms, 53.3MB)|테스트 17|통과|(75.95ms, 53.3MB)|
|테스트 8|통과|(78.59ms, 58.6MB)|테스트 18|통과|(15.52ms, 52.7MB)|
|테스트 9|통과|(12.61ms, 52.5MB)|테스트 19|통과|(61.24ms, 53.9MB)|
테스트 10|통과|(34.05ms, 53.4MB)|테스트 20|통과|(50.05ms, 53.2MB)|


재귀함수를 이용해서 해결. 단, 아쉬운점은 동적으로 위치값을 변하게 하고 싶었으나  
테스트 케이스에서의 지속적인 에러로 String값을 마킹하는 편법을 사용했다.  
그러므로써 int형의 계산을 String -> Integer변환 및 replace를 해줘야하는 상황이 발생하였다.
</div>
</details>